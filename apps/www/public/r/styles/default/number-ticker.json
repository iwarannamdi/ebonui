{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "number-counter",
  "type": "registry:ui",
  "title": "Number Ticker",
  "description": "Animate numbers to count up or down to a target number",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "registry/ebonui/number-counter.tsx",
      "content": "\"use client\"\n\nimport { ComponentPropsWithoutRef, useEffect, useRef } from \"react\"\nimport {\n  useAnimationFrame,\n  useInView,\n  useMotionValue,\n  useSpring,\n} from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface NumberTickerProps extends ComponentPropsWithoutRef<\"span\"> {\n  value: number\n  startValue?: number\n  direction?: \"up\" | \"down\"\n  delayMs?: number\n  decimalPlaces?: number\n  /** Optional spring config override */\n  springConfig?: Partial<{ damping: number; stiffness: number }>\n  /** Re-trigger animation when element comes back into view */\n  triggerOnce?: boolean\n}\n\nconst formatterCache = new Map<number, Intl.NumberFormat>()\n\nfunction getFormatter(decimalPlaces: number): Intl.NumberFormat {\n  if (!formatterCache.has(decimalPlaces)) {\n    formatterCache.set(\n      decimalPlaces,\n      new Intl.NumberFormat(\"en-US\", {\n        minimumFractionDigits: decimalPlaces,\n        maximumFractionDigits: decimalPlaces,\n      })\n    )\n  }\n  return formatterCache.get(decimalPlaces)!\n}\n\nexport function NumberTicker({\n  value,\n  startValue = 0,\n  direction = \"up\",\n  delayMs = 0,\n  decimalPlaces = 0,\n  springConfig,\n  triggerOnce = true,\n  className,\n  ...props\n}: NumberTickerProps) {\n  const ref = useRef<HTMLSpanElement>(null)\n  const motionValue = useMotionValue(direction === \"down\" ? value : startValue)\n  const springValue = useSpring(motionValue, {\n    damping: 60,\n    stiffness: 100,\n    ...springConfig,\n  })\n\n  const isInView = useInView(ref, {\n    once: triggerOnce,\n    margin: \"-100px\", // start a bit earlier for smoother feel\n  })\n\n  // Start animation when in view (with optional delay)\n  useEffect(() => {\n    if (!isInView) return\n\n    const timeout = setTimeout(() => {\n      motionValue.set(direction === \"down\" ? startValue : value)\n    }, delayMs)\n\n    return () => clearTimeout(timeout)\n  }, [isInView, motionValue, direction, value, startValue, delayMs])\n\n  // Efficiently update text content on every frame while animating\n  useAnimationFrame((time) => {\n    if (!ref.current) return\n\n    const latest = springValue.get()\n    const formatted = getFormatter(decimalPlaces).format(\n      Number(latest.toFixed(decimalPlaces))\n    )\n\n    // Only update DOM if value actually changed (prevents layout thrashing)\n    if (ref.current.textContent !== formatted) {\n      ref.current.textContent = formatted\n    }\n  })\n\n  // Initialize with correct starting value (no flicker)\n  const initialValue = direction === \"down\" ? value : startValue\n  const initialFormatted = getFormatter(decimalPlaces).format(\n    Number(initialValue.toFixed(decimalPlaces))\n  )\n\n  return (\n    <span\n      ref={ref}\n      className={cn(\n        \"inline-block tracking-wider text-black tabular-nums dark:text-white\",\n        className\n      )}\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      {...props}\n    >\n      {initialFormatted}\n    </span>\n  )\n}\n",
      "type": "registry:ui"
    }
  ]
}