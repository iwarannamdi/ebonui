{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "typing-animation",
  "title": "Typing Animation",
  "description": "Characters appearing in typed animation",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "registry/ebonui/ui/typing-animation.tsx",
      "content": "\"use client\"\n\nimport React, {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  type ElementType,\n} from \"react\"\nimport { motion, type MotionProps } from \"motion/react\"\n\nimport { cn } from \"@/lib/utils\"\n\ninterface TypingAnimationProps extends MotionProps {\n  words?: string[]\n  children?: string\n  className?: string\n  duration?: number\n  typeSpeed?: number\n  deleteSpeed?: number\n  delay?: number\n  pauseDelay?: number\n  loop?: boolean\n  showCursor?: boolean\n  cursorStyle?: \"line\" | \"block\" | \"underscore\"\n  as?: ElementType\n  \"aria-label\"?: string\n}\n\nconst DEFAULT_TYPE_SPEED = 80\nconst DEFAULT_DELETE_SPEED = 40\nconst DEFAULT_PAUSE_DELAY = 1200\n\nexport function TypingAnimation({\n  words: propWords,\n  children,\n  className,\n  duration,\n  typeSpeed = duration || DEFAULT_TYPE_SPEED,\n  deleteSpeed = duration ? duration / 2 : DEFAULT_DELETE_SPEED,\n  delay = 0,\n  pauseDelay = DEFAULT_PAUSE_DELAY,\n  loop = false,\n  showCursor = true,\n  cursorStyle = \"line\",\n  as: Component = \"span\",\n  \"aria-label\": ariaLabel,\n  ...motionProps\n}: TypingAnimationProps) {\n  const words = propWords || (children ? [children] : [])\n\n  const [displayedText, setDisplayedText] = useState(\"\")\n  const [phase, setPhase] = useState<\n    \"waiting\" | \"typing\" | \"pausing\" | \"deleting\"\n  >(\"waiting\")\n  const [wordIndex, setWordIndex] = useState(0)\n  const [charIndex, setCharIndex] = useState(0)\n\n  const frameRef = useRef<number | undefined>(undefined)\n  const lastTimestampRef = useRef<number>(0)\n  const initialDelayDoneRef = useRef(false)\n\n  // Refs for mutable state to keep animate stable\n  const phaseRef = useRef(phase)\n  const wordIndexRef = useRef(wordIndex)\n  const charIndexRef = useRef(charIndex)\n\n  // Sync refs with state\n  useEffect(() => {\n    phaseRef.current = phase\n  }, [phase])\n  useEffect(() => {\n    wordIndexRef.current = wordIndex\n  }, [wordIndex])\n  useEffect(() => {\n    charIndexRef.current = charIndex\n  }, [charIndex])\n\n  const getCursor = () => {\n    switch (cursorStyle) {\n      case \"block\":\n        return \"▋\"\n      case \"underscore\":\n        return \"_\"\n      case \"line\":\n      default:\n        return \"|\"\n    }\n  }\n\n  const animate = useCallback(\n    (timestamp: number) => {\n      if (words.length === 0) return\n\n      if (!lastTimestampRef.current) lastTimestampRef.current = timestamp\n\n      const delta = timestamp - lastTimestampRef.current\n\n      // Initial delay\n      if (!initialDelayDoneRef.current) {\n        if (delta >= delay) {\n          initialDelayDoneRef.current = true\n          setPhase(\"typing\")\n          phaseRef.current = \"typing\"\n          lastTimestampRef.current = timestamp\n        }\n        frameRef.current = requestAnimationFrame(animate)\n        return\n      }\n\n      const currentWord = words[wordIndexRef.current] || \"\"\n      const graphemes = Array.from(\n        new Intl.Segmenter().segment(currentWord)\n      ).map((s) => s.segment)\n      const targetIndex = phaseRef.current === \"deleting\" ? 0 : graphemes.length\n\n      if (phaseRef.current === \"typing\" || phaseRef.current === \"deleting\") {\n        const speed = phaseRef.current === \"typing\" ? typeSpeed : deleteSpeed\n        if (delta >= speed) {\n          const nextIndex =\n            phaseRef.current === \"typing\"\n              ? charIndexRef.current + 1\n              : charIndexRef.current - 1\n\n          setDisplayedText(graphemes.slice(0, nextIndex).join(\"\"))\n          setCharIndex(nextIndex)\n          // No need to set refs here—synced via effects\n          lastTimestampRef.current = timestamp\n\n          if (nextIndex === targetIndex) {\n            if (phaseRef.current === \"typing\") {\n              const isLastWord = wordIndexRef.current === words.length - 1\n              if (loop || !isLastWord) {\n                setPhase(\"pausing\")\n                phaseRef.current = \"pausing\"\n                lastTimestampRef.current = timestamp\n              }\n            } else {\n              // Finished deleting → next word (if not stopping)\n              const nextWordIndex = (wordIndexRef.current + 1) % words.length\n              setWordIndex(nextWordIndex)\n              wordIndexRef.current = nextWordIndex\n              setCharIndex(0)\n              charIndexRef.current = 0\n              setPhase(\"typing\")\n              phaseRef.current = \"typing\"\n            }\n          }\n        }\n      } else if (phaseRef.current === \"pausing\" && delta >= pauseDelay) {\n        setPhase(\"deleting\")\n        phaseRef.current = \"deleting\"\n        lastTimestampRef.current = timestamp // Reset here to start deleting immediately\n      }\n\n      frameRef.current = requestAnimationFrame(animate)\n    },\n    // Stable deps only—no states!\n    [words, typeSpeed, deleteSpeed, pauseDelay, delay, loop]\n  )\n\n  // Start/stop animation\n  useEffect(() => {\n    if (words.length === 0) return\n\n    lastTimestampRef.current = performance.now()\n    frameRef.current = requestAnimationFrame(animate)\n\n    return () => {\n      if (frameRef.current) cancelAnimationFrame(frameRef.current)\n      frameRef.current = undefined\n      lastTimestampRef.current = 0\n      initialDelayDoneRef.current = false\n    }\n  }, [animate, words]) // No words.length—use words (stable array ref)\n\n  // Reset when words change\n  useEffect(() => {\n    setDisplayedText(\"\")\n    setWordIndex(0)\n    setCharIndex(0)\n    setPhase(\"waiting\")\n    // Sync refs\n    wordIndexRef.current = 0\n    charIndexRef.current = 0\n    phaseRef.current = \"waiting\"\n    initialDelayDoneRef.current = false\n    lastTimestampRef.current = 0\n  }, [words])\n\n  if (words.length === 0) {\n    return null\n  }\n\n  const currentGraphemes = Array.from(\n    new Intl.Segmenter().segment(words[wordIndex] || \"\")\n  ).map((s) => s.segment)\n\n  const isDone =\n    !loop &&\n    wordIndex === words.length - 1 &&\n    charIndex === currentGraphemes.length &&\n    phase !== \"deleting\" &&\n    phase !== \"pausing\"\n\n  const showCursorFinal = showCursor && !isDone\n\n  return (\n    <motion.span\n      className={cn(\"inline-block\", className)}\n      aria-live=\"polite\"\n      aria-label={ariaLabel || displayedText || undefined}\n      {...motionProps}\n    >\n      <Component className=\"inline\">\n        {displayedText}\n        {showCursorFinal && (\n          <span\n            className=\"ml-0.5 inline-block w-[0.1em] translate-y-[0.1em] animate-pulse font-bold text-current\"\n            aria-hidden=\"true\"\n          >\n            {getCursor()}\n          </span>\n        )}\n      </Component>\n    </motion.span>\n  )\n}\n",
      "type": "registry:ui"
    }
  ],
  "cssVars": {
    "theme": {
      "animate-blink-cursor": "blink-cursor 1.2s step-end infinite"
    }
  },
  "css": {
    "@keyframes blink-cursor": {
      "0%, 49%": {
        "opacity": "1"
      },
      "50%, 100%": {
        "opacity": "0"
      }
    }
  },
  "type": "registry:ui"
}